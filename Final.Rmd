---
title: "STAT 380 Final Project"
author: "Brian Ellis and James Tondt"
date: "2023-04-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Front Matter
```{r, message = FALSE, warning = FALSE}
rm(list = ls())
#Add libraries as needed
library(tidyverse)
```

## Call of Duty

![CODGames](Call-of-Duty.jpg-d196774.png)

```{r}
# Load datasets
P1 <- read_csv(file = "CODGames_p1_380.csv", show_col_types = FALSE)
head(P1)

P2 <- read_csv("CODGames_p2_380.csv", show_col_types = FALSE)
head(P2)

Maps <- read_csv("CODMaps.csv")
head(Maps)

Modes <- read_csv("CODGameModes.csv")
Modes
```

```{r}
# Appending Player 2 df to Player 1 df
Players <- P1 %>% 
  rbind(P2)
head(Players)
```

## Task 1 (Data Cleaning and Visualization)

Research Question: Which maps are the most likely to win the map vote? 

In order to answer this question, a good place to start would be to clean the data in the Map and Choice columns so that there are no NA values or misspellings. We can then run some summary statistics and visualizations to discover the amount of times a map has won the map vote or was selected as the choice. We will have to make a decision as to whether or not we will include those maps who were chosen by default due to a player entering a game partially, because we would lose the information of which map the winning map faced in the vote. We also believe that calculating the proportion of winning percentage for each map would be more beneficial than simple counting stats because we can see the winning percentage of maps. We will account for the fact that if there is a tie in voting, Map 1 is chosen by default. Therefore, we will locate whenever there is a tie and disregard the 'Choice' for that particular row. Games which are already underway already have the chosen map listed in choice so we don't care about the map votes for these rows. If we look at the variable 'Choice',
```{r}
sum(is.na(Players$Choice))
```
we see that there are only 2 NA values, so most of our data is present.

```{r}
unique(Players$Choice)
unique(Maps$Name)
```

We can see that there are more unique map names in our Players dataframe as compared with the list of all the map names from our Maps dataframe. This shows us there are misspellings in the map names in the Players dataframe that we must correct before calculating summary statistics.

```{r}
Maps %>% 
  full_join(Players, by = c("Name" = "Choice")) %>% 
  group_by(Name) %>% 
  summarize(Count = n())
```


Using this join query, we can see there are multiple misspellings, added spaces, and a couple NA values. We shall correct for all this before running summaries.

Before running summary statistics, we must clean the data contained within the Choice and Map variables

```{r}
# Choice Data Cleaning
# remove NAs from Choice since there are only 2
Players <- Players %>% 
  drop_na(Choice)
# Remove trailing or leading spaces
Players <- Players %>% 
  mutate(Choice = trimws(Choice),
         Map1 = trimws(Map1),
         Map2 = trimws(Map2))

# Define a list of misspellings and their correct spellings and specify certain spellings for words with spaces in their names with '\\W'
misspellings <- list("APocalypse" = "Apocalypse", "Apocolypse" = "Apocalypse", "\\bCollaterel Strike\\b" = "Collateral", "\\bCollateral Strike\\b" = "Collateral", "Deisel" = "Diesel", "Drive-in" = "Drive-In", "\\bMiami Strike\\b" = "MiamiStrike", "\\bNuketown\\b.*" = "Nuketown", "Riad" = "Raid")

# Loop through the misspellings list and apply regex to correct the misspellings
for (misspelling in names(misspellings)) {
  correction <- misspellings[[misspelling]]
  Players$Choice <- gsub(misspelling, correction, Players$Choice, ignore.case = TRUE)
}
# Run new query to see if misspellings were corrected
Players %>% 
  group_by(Choice) %>% 
  summarise(Count = n())
```

We ended up changing some map names, e.g., "Collateral Strike" is now just "Collateral" and "Miami Strike" is "MiamiStrike". We needed to make these map names single words because otherwise the loop would not process or recognize the names correctly once they were altered.

Our misspellings are corrected and we can perform this data cleaning process on Map1 and Map2 variables now

```{r}
sum(is.na(Players$Map1))
sum(is.na(Players$Map2))
Players %>% 
  filter(FullPartial == "Partial") %>% 
  summarize(Count = n())
```

Both Map1 and Map2 variables have 163 missing values even though there are only 80 Partial games in the dataset. Therefore, we shouldn't remove the rows with NA values because those rows still have Choice values. Let's see if we can find typos in the map names by comparing them with the Map table

```{r}
Maps %>% 
  full_join(Players, by = c("Name" = "Map1")) %>% 
  group_by(Name) %>% 
  summarize(Count = n())
```

Since there are new typos, we just need to adjust our misspellings list to account for these. Note, we use the '\\b' encasing to denote we want to only replace the value when it matches exactly that spelling.

```{r}
# Map1 Data Cleaning
# Define a list of misspellings and their correct spellings and specify certain spellings for words with spaces in their names with '\\b'
misspellings <- list("\\bCollateral Striek\\b" = "Collateral", "\\bCollateral Strike\\b" = "Collateral", "\\bCollaterol Strike\\b" = "Collateral", "Deprogam" = "Deprogram", "Drive-in" = "Drive-In", "\\bMiami Stirke\\b" = "MiamiStrike", "\\bMiami Strike\\b" = "MiamiStrike", "\\bNuketown '84\\b" = "Nuketown", "Riad" = "Raid", "Ruah" = "Rush")

# Loop through the misspellings list and apply regex to correct the misspellings
for (misspelling in names(misspellings)) {
  correction <- misspellings[[misspelling]]
  Players$Map1 <- gsub(misspelling, correction, Players$Map1, ignore.case = TRUE)
}
# Run new query to see if misspellings were corrected
Players %>% 
  group_by(Map1) %>% 
  summarise(Count = n())
```

Great, now we just have to clean the names of Map2 and we can begin performing visualizations and running summary statistics.

```{r}
Maps %>% 
  full_join(Players, by = c("Name" = "Map2")) %>% 
  group_by(Name) %>% 
  summarize(Count = n())
```

FIX MIAMI VS MIAMI STRIKE!!!    

```{r}
# Map2 Data Cleaning
# Define a list of misspellings and their correct spellings
misspellings <- list("\\bAmrada Strike\\b" = "Armada Strike", "\\bCollateral Strike\\b" = "Collateral", "Drive-in" = "Drive-In", "\\bMiami Sstrike\\b" = "MiamiStrike", "\\bMiami Stirke\\b" = "MiamiStrike", "\\bMiami Strike\\b" = "MiamiStrike", "\\bNuketown\\b.*" = "Nuketown", "\\byamantau\\b" = "Yamantau")

# Loop through the misspellings list and apply regex to correct the misspellings
for (misspelling in names(misspellings)) {
  correction <- misspellings[[misspelling]]
  Players$Map2 <- gsub(misspelling, correction, Players$Map2, ignore.case = TRUE)
}
# Run new query to see if misspellings were corrected
Players %>% 
  group_by(Map2) %>% 
  summarise(Count = n())
```

Now that our data is cleaned and variables match each other, we can begin visualizing the data.

```{r}
# Visualization of Choice
Players %>% 
  ggplot(aes(x = Choice)) +
  geom_histogram(stat = "count") +
  labs(title = "Distribution of Choice",
       x = "Choice",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```


```{r}
# Visualization of Map 1
Players %>% 
  ggplot(aes(x = Map1)) +
  geom_histogram(stat = "count") +
  labs(title = "Distribution of Map 1",
       x = "Map",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

# Visualization of Map 2
Players %>% 
  ggplot(aes(x = Map2)) +
  geom_histogram(stat = "count", na.rm = TRUE) +
  labs(title = "Distribution of Map 2",
       x = "Map",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

From these visualizations, we can verify that the map names do not change but the distributions do. Our data cleaning is complete and we can now move onto calculating proportions.

Now we need to work with the MapVote variable and identify when a tie takes place. This is important, because whenever there is a tie Map1 gets chosen by default.

```{r}
table(Players$Choice)
```



# Task 2

```{r}

# Clean the data to clear to distinction between HC-TDM/Hardpoint and TDM/Hardpoint

Players <- 
  Players %>%
  mutate(GameType = str_replace(GameType, "HC - ", "")) 

# Check to see if data was properly cleaned and if there are any NAs
Players %>% 
  group_by(GameType) %>% 
  summarise(Count = n())

```


The GameType column has been cleaned so we can now start an exploratory data analysis. 


```{r}
ggplot(Players,
       aes(x = Score, y = TotalXP, color = GameType)) +
  geom_point() +
  labs(title = "Total experience points vs Score by Game Type",
       y = "Total experience points")

```


```{r}
ggplot(Players, aes(x = GameType, y = TotalXP)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Distribution of Total experience points by Game Type")

ggplot(Players, aes(x = GameType, y = Score)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Distribution of Score by Game Type")

```

```{r}

```



```{r}
model1 <- lm(TotalXP ~ Score + GameType, data = Players)
summary(model1)

```

