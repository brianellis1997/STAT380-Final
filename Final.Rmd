---
title: "STAT 380 Final Project"
author: "Brian Ellis and James Tondt"
date: "2023-04-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Remember to customize plot axis titles and labels. Professor takes off points for non-customized labels and visualizations

## Front Matter
```{r, message = FALSE, warning = FALSE}
rm(list = ls())
#Add libraries as needed
library(tidyverse)
```

## Call of Duty

![CODGames](Call-of-Duty.jpg-d196774.png)

```{r}
# Load datasets
P1 <- read_csv(file = "CODGames_p1_380.csv", show_col_types = FALSE)
head(P1)

P2 <- read_csv("CODGames_p2_380.csv", show_col_types = FALSE)
head(P2)

Maps <- read_csv("CODMaps.csv")
head(Maps)

Modes <- read_csv("CODGameModes.csv")
Modes
```

```{r}
# Appending Player 2 df to Player 1 df
Players <- P1 %>% 
  rbind(P2)
head(Players)
```

## Task 1 (Data Cleaning and Visualization)

Research Question: Which maps are the most likely to win the map vote? 

In order to answer this question, a good place to start would be to clean the data in the Map and Choice columns so that there are no NA values or misspellings. We can then run some summary statistics and visualizations to discover the amount of times a map has won the map vote or was selected as the choice. We will have to make a decision as to whether or not we will include those maps who were chosen by default due to a player entering a game partially, because we would lose the information of which map the winning map faced in the vote. We also believe that calculating the proportion of winning percentage for each map would be more beneficial than simple counting stats because we can see the winning percentage of maps. We will account for the fact that if there is a tie in voting, Map 1 is chosen by default. Therefore, we will locate whenever there is a tie and disregard the 'Choice' for that particular row. Games which are already underway already have the chosen map listed in choice so we don't care about the map votes for these rows. If we look at the variable 'Choice',
```{r}
sum(is.na(Players$Choice))
```
we see that there are only 2 NA values, so most of our data is present.

```{r}
unique(Players$Choice)
unique(Maps$Name)
```

We can see that there are more unique map names in our Players dataframe as compared with the list of all the map names from our Maps dataframe. This shows us there are misspellings in the map names in the Players dataframe that we must correct before calculating summary statistics.

```{r}
Maps %>% 
  full_join(Players, by = c("Name" = "Choice")) %>% 
  group_by(Name) %>% 
  summarize(Count = n())
```


Using this join query, we can see there are multiple misspellings, added spaces, and a couple NA values. We shall correct for all this before running summaries.

Before running summary statistics, we must clean the data contained within the Choice and Map variables

```{r}
# Choice Data Cleaning
# remove NAs from Choice since there are only 2
Players <- Players %>% 
  drop_na(Choice)
# Remove trailing or leading spaces
Players <- Players %>% 
  mutate(Choice = trimws(Choice),
         Map1 = trimws(Map1),
         Map2 = trimws(Map2))

# Define a list of misspellings and their correct spellings and specify certain spellings for words with spaces in their names with '\\W'
misspellings <- list("APocalypse" = "Apocalypse", "Apocolypse" = "Apocalypse", "\\bCollaterel Strike\\b" = "Collateral", "\\bCollateral Strike\\b" = "Collateral", "Deisel" = "Diesel", "Drive-in" = "Drive-In", "\\bMiami Strike\\b" = "MiamiStrike", "\\bNuketown\\b.*" = "Nuketown", "Riad" = "Raid")

# Loop through the misspellings list and apply regex to correct the misspellings
for (misspelling in names(misspellings)) {
  correction <- misspellings[[misspelling]]
  Players$Choice <- gsub(misspelling, correction, Players$Choice, ignore.case = TRUE)
}
# Run new query to see if misspellings were corrected
Players %>% 
  group_by(Choice) %>% 
  summarise(Count = n())
```

We ended up changing some map names, e.g., "Collateral Strike" is now just "Collateral" and "Miami Strike" is "MiamiStrike". We needed to make these map names single words because otherwise the loop would not process or recognize the names correctly once they were altered.

Our misspellings are corrected and we can perform this data cleaning process on Map1 and Map2 variables now

```{r}
sum(is.na(Players$Map1))
sum(is.na(Players$Map2))
Players %>% 
  filter(FullPartial == "Partial") %>% 
  summarize(Count = n())
```

Both Map1 and Map2 variables have 163 missing values even though there are only 80 Partial games in the dataset. Therefore, we shouldn't remove the rows with NA values because those rows still have Choice values. Let's see if we can find typos in the map names by comparing them with the Map table

```{r}
Maps %>% 
  full_join(Players, by = c("Name" = "Map1")) %>% 
  group_by(Name) %>% 
  summarize(Count = n())
```

Since there are new typos, we just need to adjust our misspellings list to account for these. Note, we use the '\\b' encasing to denote we want to only replace the value when it matches exactly that spelling.

```{r}
# Map1 Data Cleaning
# Define a list of misspellings and their correct spellings and specify certain spellings for words with spaces in their names with '\\b'
misspellings <- list("\\bCollateral Striek\\b" = "Collateral", "\\bCollateral Strike\\b" = "Collateral", "\\bCollaterol Strike\\b" = "Collateral", "Deprogam" = "Deprogram", "Drive-in" = "Drive-In", "\\bMiami Stirke\\b" = "MiamiStrike", "\\bMiami Strike\\b" = "MiamiStrike", "\\bNuketown '84\\b" = "Nuketown", "Riad" = "Raid", "Ruah" = "Rush")

# Loop through the misspellings list and apply regex to correct the misspellings
for (misspelling in names(misspellings)) {
  correction <- misspellings[[misspelling]]
  Players$Map1 <- gsub(misspelling, correction, Players$Map1, ignore.case = TRUE)
}
# Run new query to see if misspellings were corrected
Players %>% 
  group_by(Map1) %>% 
  summarise(Count = n())
```

Great, now we just have to clean the names of Map2 and we can begin performing visualizations and running summary statistics.

```{r}
Maps %>% 
  full_join(Players, by = c("Name" = "Map2")) %>% 
  group_by(Name) %>% 
  summarize(Count = n())
```

FIX MIAMI VS MIAMI STRIKE!!!    

```{r}
# Map2 Data Cleaning
# Define a list of misspellings and their correct spellings
misspellings <- list("\\bAmrada Strike\\b" = "Armada Strike", "\\bCollateral Strike\\b" = "Collateral", "Drive-in" = "Drive-In", "\\bMiami Sstrike\\b" = "MiamiStrike", "\\bMiami Stirke\\b" = "MiamiStrike", "\\bMiami Strike\\b" = "MiamiStrike", "\\bNuketown\\b.*" = "Nuketown", "\\byamantau\\b" = "Yamantau")

# Loop through the misspellings list and apply regex to correct the misspellings
for (misspelling in names(misspellings)) {
  correction <- misspellings[[misspelling]]
  Players$Map2 <- gsub(misspelling, correction, Players$Map2, ignore.case = TRUE)
}
# Run new query to see if misspellings were corrected
Players %>% 
  group_by(Map2) %>% 
  summarise(Count = n())
```

Now that our data is cleaned and variables match each other, we can begin visualizing the data.

```{r}
# Visualization of Choice
Players %>% 
  ggplot(aes(x = Choice)) +
  geom_histogram(stat = "count") +
  labs(title = "Distribution of Choice",
       x = "Choice",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```


```{r}
# Visualization of Map 1
Players %>% 
  ggplot(aes(x = Map1)) +
  geom_histogram(stat = "count") +
  labs(title = "Distribution of Map 1",
       x = "Map",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

# Visualization of Map 2
Players %>% 
  ggplot(aes(x = Map2)) +
  geom_histogram(stat = "count", na.rm = TRUE) +
  labs(title = "Distribution of Map 2",
       x = "Map",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

From these visualizations, we can verify that the map names do not change but the distributions do. Our data cleaning is complete and we can now move onto calculating proportions.

Now we need to work with the MapVote variable and identify when a tie takes place. This is important, because whenever there is a tie Map1 gets chosen by default. We will first alter the MapVote variable into a numerical form where we can compare the two numbers in the column between eachother and store each time the two numbers are equivalent.

```{r}
# Remove NAs from Mapvote
Map_vote <- Players$MapVote
Map_vote <- na.omit(Map_vote)
# Split Mapvote
Vote_split <- strsplit(Map_vote, "to")

# Remove NA values
# Vote_split <- na.omit(Vote_split) <- Don't know if this is necessary

# Initialize storage
First_vote <- rep(NA, length(Vote_split))
Second_vote <- rep(NA, length(Vote_split))
Draw <- rep(NA, length(Vote_split))

# Loop through Vote_split and store first and second vote numbers
for (i in 1:length(Vote_split)) {
  First_vote[i] <- (Vote_split[[i]][1])
  Second_vote[i] <- (Vote_split[[i]][2])
}

print(tail(First_vote, 200))
print(which(First_vote == "4 o 0"))
print(which(First_vote == "2 o 0"))
print(length(First_vote))
print(length(Second_vote))
```

We see that there are some entries that do not represent numbers that will be unsuccessfully converted to numeric values if we were to convert them now. We must impute these values and figure out there true meaning. The two entries in question from our vector First_vote are "4 o 0" and "2 o 0". This relates to a fundamental problem in our strsplit initially. The word "to" is misspelled as "o", meaning that these numbers will not be recognized by our split. This doesn't cause us an issue in this case because we are only concerned with the votes that ended up being ties and it seems like the votes were "2 to 0" and "4 to 0" respectively. This is something to note at the very least, let's now check our Second_vote vector to see the values before we convert them to numeric.

Now we know we must fix our strsplit function to cover these two cases.


```{r}
# Split Mapvote by "to" or "o"
Vote_split <- strsplit(Map_vote, "to|o")

# Remove NA values
# Vote_split <- na.omit(Vote_split) <- Don't know if this is necessary

# Initialize storage
First_vote <- rep(NA, length(Vote_split))
Second_vote <- rep(NA, length(Vote_split))
Draw <- rep(NA, length(Vote_split))

# Loop through Vote_split and store first and second vote numbers
for (i in 1:length(Vote_split)) {
  First_vote[i] <- (Vote_split[[i]][1])
  Second_vote[i] <- (Vote_split[[i]][2])
}

print(tail(First_vote, 200))
print(which(First_vote == "4 o 0"))
print(which(First_vote == "2 o 0"))
print(length(First_vote))
print(length(Second_vote))
```

Now we can't find the previous misspelled values and our number of rows are still same for our vectors.

We can compare the two vectors and count the number of times they match which would be equivalent to a draw. It is important that we keep the original order of our data frame so that we can know which rows ended in draws. We can then append the draw vector to our original data frame.

```{r}
# Convert to numeric
First_vote <- as.numeric(First_vote)
Second_vote <- as.numeric(Second_vote)

# Store Boolean values for equality
equal_elements <- First_vote == Second_vote
# Extract elements that are equal
equal_values <- First_vote[equal_elements]

# Count number of equal occurrences
num_equal <- sum(equal_elements)

# Print the extracted elements and count
print(head(equal_values))
print(num_equal)
```

We now arrive at the number of times there was a draw in map votes between two maps. We know that whenever this occurs, Map1 is chosen by default. We can take this into consideration during our calculations.

Whenever the map vote results in a tie, we should discard the result of Choice and not consider it as a win.

# Task 2

```{r}

# Clean the data to clear to distinction between HC-TDM/Hardpoint and TDM/Hardpoint

Players <- 
  Players %>%
  mutate(GameType = str_replace(GameType, "HC - ", "")) 

# Check to see if data was properly cleaned and if there are any NAs
Players %>% 
  group_by(GameType) %>% 
  summarise(Count = n())

```


The GameType column has been cleaned so we can now start an exploratory data analysis. 


```{r}
ggplot(Players,
       aes(x = Score, y = TotalXP, color = GameType)) +
  geom_point() +
  labs(title = "Total experience points vs Score by Game Type",
       y = "Total experience points")

```


```{r}
ggplot(Players, aes(x = GameType, y = TotalXP)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Distribution of Total experience points by Game Type",
       x = "Game Type")

ggplot(Players, aes(x = GameType, y = Score)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Distribution of Score by Game Type",
       x = "Game Type")

```

```{r}

```



```{r}
model1 <- lm(TotalXP ~ Score + GameType, data = Players)
summary(model1)

```

